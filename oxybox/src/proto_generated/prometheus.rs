// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MetricMetadata {
    #[prost(enumeration = "metric_metadata::MetricType", tag = "1")]
    pub r#type: i32,
    #[prost(string, tag = "2")]
    pub metric_family_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub help: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub unit: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MetricMetadata`.
pub mod metric_metadata {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MetricType {
        Unknown = 0,
        Counter = 1,
        Gauge = 2,
        Histogram = 3,
        Gaugehistogram = 4,
        Summary = 5,
        Info = 6,
        Stateset = 7,
    }
    impl MetricType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Counter => "COUNTER",
                Self::Gauge => "GAUGE",
                Self::Histogram => "HISTOGRAM",
                Self::Gaugehistogram => "GAUGEHISTOGRAM",
                Self::Summary => "SUMMARY",
                Self::Info => "INFO",
                Self::Stateset => "STATESET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "COUNTER" => Some(Self::Counter),
                "GAUGE" => Some(Self::Gauge),
                "HISTOGRAM" => Some(Self::Histogram),
                "GAUGEHISTOGRAM" => Some(Self::Gaugehistogram),
                "SUMMARY" => Some(Self::Summary),
                "INFO" => Some(Self::Info),
                "STATESET" => Some(Self::Stateset),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Sample {
    #[prost(double, tag = "1")]
    pub value: f64,
    #[prost(int64, tag = "2")]
    pub timestamp: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Exemplar {
    #[prost(message, repeated, tag = "1")]
    pub labels: ::prost::alloc::vec::Vec<Label>,
    #[prost(double, tag = "2")]
    pub value: f64,
    #[prost(int64, tag = "3")]
    pub timestamp: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Histogram {
    #[prost(double, tag = "3")]
    pub sum: f64,
    #[prost(sint32, tag = "4")]
    pub schema: i32,
    #[prost(double, tag = "5")]
    pub zero_threshold: f64,
    #[prost(message, repeated, tag = "8")]
    pub negative_spans: ::prost::alloc::vec::Vec<BucketSpan>,
    #[prost(sint64, repeated, tag = "9")]
    pub negative_deltas: ::prost::alloc::vec::Vec<i64>,
    #[prost(double, repeated, tag = "10")]
    pub negative_counts: ::prost::alloc::vec::Vec<f64>,
    #[prost(message, repeated, tag = "11")]
    pub positive_spans: ::prost::alloc::vec::Vec<BucketSpan>,
    #[prost(sint64, repeated, tag = "12")]
    pub positive_deltas: ::prost::alloc::vec::Vec<i64>,
    #[prost(double, repeated, tag = "13")]
    pub positive_counts: ::prost::alloc::vec::Vec<f64>,
    #[prost(enumeration = "histogram::ResetHint", tag = "14")]
    pub reset_hint: i32,
    #[prost(int64, tag = "15")]
    pub timestamp: i64,
    #[prost(double, repeated, tag = "16")]
    pub custom_values: ::prost::alloc::vec::Vec<f64>,
    #[prost(oneof = "histogram::Count", tags = "1, 2")]
    pub count: ::core::option::Option<histogram::Count>,
    #[prost(oneof = "histogram::ZeroCount", tags = "6, 7")]
    pub zero_count: ::core::option::Option<histogram::ZeroCount>,
}
/// Nested message and enum types in `Histogram`.
pub mod histogram {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResetHint {
        Unknown = 0,
        Yes = 1,
        No = 2,
        Gauge = 3,
    }
    impl ResetHint {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Yes => "YES",
                Self::No => "NO",
                Self::Gauge => "GAUGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "YES" => Some(Self::Yes),
                "NO" => Some(Self::No),
                "GAUGE" => Some(Self::Gauge),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Count {
        #[prost(uint64, tag = "1")]
        CountInt(u64),
        #[prost(double, tag = "2")]
        CountFloat(f64),
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ZeroCount {
        #[prost(uint64, tag = "6")]
        ZeroCountInt(u64),
        #[prost(double, tag = "7")]
        ZeroCountFloat(f64),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BucketSpan {
    #[prost(sint32, tag = "1")]
    pub offset: i32,
    #[prost(uint32, tag = "2")]
    pub length: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeries {
    #[prost(message, repeated, tag = "1")]
    pub labels: ::prost::alloc::vec::Vec<Label>,
    #[prost(message, repeated, tag = "2")]
    pub samples: ::prost::alloc::vec::Vec<Sample>,
    #[prost(message, repeated, tag = "3")]
    pub exemplars: ::prost::alloc::vec::Vec<Exemplar>,
    #[prost(message, repeated, tag = "4")]
    pub histograms: ::prost::alloc::vec::Vec<Histogram>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Label {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Labels {
    #[prost(message, repeated, tag = "1")]
    pub labels: ::prost::alloc::vec::Vec<Label>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LabelMatcher {
    #[prost(enumeration = "label_matcher::Type", tag = "1")]
    pub r#type: i32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub value: ::prost::alloc::string::String,
}
/// Nested message and enum types in `LabelMatcher`.
pub mod label_matcher {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Eq = 0,
        Neq = 1,
        Re = 2,
        Nre = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Eq => "EQ",
                Self::Neq => "NEQ",
                Self::Re => "RE",
                Self::Nre => "NRE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EQ" => Some(Self::Eq),
                "NEQ" => Some(Self::Neq),
                "RE" => Some(Self::Re),
                "NRE" => Some(Self::Nre),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadHints {
    #[prost(int64, tag = "1")]
    pub step_ms: i64,
    #[prost(string, tag = "2")]
    pub func: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub start_ms: i64,
    #[prost(int64, tag = "4")]
    pub end_ms: i64,
    #[prost(string, repeated, tag = "5")]
    pub grouping: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "6")]
    pub by: bool,
    #[prost(int64, tag = "7")]
    pub range_ms: i64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Chunk {
    #[prost(int64, tag = "1")]
    pub min_time_ms: i64,
    #[prost(int64, tag = "2")]
    pub max_time_ms: i64,
    #[prost(enumeration = "chunk::Encoding", tag = "3")]
    pub r#type: i32,
    #[prost(bytes = "vec", tag = "4")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `Chunk`.
pub mod chunk {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Encoding {
        Unknown = 0,
        Xor = 1,
        Histogram = 2,
        FloatHistogram = 3,
    }
    impl Encoding {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Xor => "XOR",
                Self::Histogram => "HISTOGRAM",
                Self::FloatHistogram => "FLOAT_HISTOGRAM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "XOR" => Some(Self::Xor),
                "HISTOGRAM" => Some(Self::Histogram),
                "FLOAT_HISTOGRAM" => Some(Self::FloatHistogram),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkedSeries {
    #[prost(message, repeated, tag = "1")]
    pub labels: ::prost::alloc::vec::Vec<Label>,
    #[prost(message, repeated, tag = "2")]
    pub chunks: ::prost::alloc::vec::Vec<Chunk>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteRequest {
    #[prost(message, repeated, tag = "1")]
    pub timeseries: ::prost::alloc::vec::Vec<TimeSeries>,
    #[prost(message, repeated, tag = "3")]
    pub metadata: ::prost::alloc::vec::Vec<MetricMetadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadRequest {
    #[prost(message, repeated, tag = "1")]
    pub queries: ::prost::alloc::vec::Vec<Query>,
    #[prost(enumeration = "read_request::ResponseType", repeated, tag = "2")]
    pub accepted_response_types: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `ReadRequest`.
pub mod read_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResponseType {
        Samples = 0,
        StreamedXorChunks = 1,
    }
    impl ResponseType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Samples => "SAMPLES",
                Self::StreamedXorChunks => "STREAMED_XOR_CHUNKS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SAMPLES" => Some(Self::Samples),
                "STREAMED_XOR_CHUNKS" => Some(Self::StreamedXorChunks),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<QueryResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Query {
    #[prost(int64, tag = "1")]
    pub start_timestamp_ms: i64,
    #[prost(int64, tag = "2")]
    pub end_timestamp_ms: i64,
    #[prost(message, repeated, tag = "3")]
    pub matchers: ::prost::alloc::vec::Vec<LabelMatcher>,
    #[prost(message, optional, tag = "4")]
    pub hints: ::core::option::Option<ReadHints>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResult {
    #[prost(message, repeated, tag = "1")]
    pub timeseries: ::prost::alloc::vec::Vec<TimeSeries>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkedReadResponse {
    #[prost(message, repeated, tag = "1")]
    pub chunked_series: ::prost::alloc::vec::Vec<ChunkedSeries>,
    #[prost(int64, tag = "2")]
    pub query_index: i64,
}
